// /api/validate-key.js - API key validation endpoint
import crypto from 'crypto';

// In-memory API key storage (in production, use a database)
let apiKeys = {};
let validationHistory = [];

// User database reference (should match auth.js)
const USERS = {
    'demo1': { accessType: 'trial', approved: true },
    'trial_user': { accessType: 'trial', approved: true },
    'test_user': { accessType: 'trial', approved: true },
    'student1': { accessType: 'trial', approved: true },
    'preview': { accessType: 'trial', approved: true },
    'premium1': { accessType: 'unlimited', approved: true },
    'vip_user': { accessType: 'unlimited', approved: true },
    'client_alpha': { accessType: 'unlimited', approved: true },
    'student_pro': { accessType: 'unlimited', approved: true },
    'admin': { accessType: 'admin', approved: true },
    'sathelper_admin': { accessType: 'admin', approved: true },
    'owner': { accessType: 'admin', approved: true }
};

function logSecurityEvent(event, details) {
    const logEntry = {
        timestamp: new Date().toISOString(),
        event,
        details
    };
    
    validationHistory.push(logEntry);
    
    // Keep only last 1000 entries
    if (validationHistory.length > 1000) {
        validationHistory = validationHistory.slice(-1000);
    }
    
    console.log(`[API] [${logEntry.timestamp}] ${event}: ${details}`);
}

// Initialize some test API keys (in production, these would be generated by auth endpoint)
function initializeTestKeys() {
    if (Object.keys(apiKeys).length === 0) {
        // Generate some test API keys for demonstration
        const testKeys = {
            'ak_demo_trial_2024': {
                username: 'trial_user',
                accessType: 'trial',
                createdAt: new Date().toISOString(),
                expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString() // 1 year
            },
            'ak_premium_unlimited_2024': {
                username: 'premium1',
                accessType: 'unlimited',
                createdAt: new Date().toISOString(),
                expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString()
            },
            'ak_admin_master_2024': {
                username: 'admin',
                accessType: 'admin',
                createdAt: new Date().toISOString(),
                expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString()
            }
        };
        
        Object.assign(apiKeys, testKeys);
        console.log('Test API keys initialized');
    }
}

function storeApiKey(apiKey, username, accessType) {
    const expiresAt = new Date();
    expiresAt.setFullYear(expiresAt.getFullYear() + 1); // 1 year from now
    
    apiKeys[apiKey] = {
        username: username,
        accessType: accessType,
        createdAt: new Date().toISOString(),
        expiresAt: expiresAt.toISOString(),
        lastUsed: new Date().toISOString()
    };
}

export default async function handler(req, res) {
    // Initialize test keys on first run
    initializeTestKeys();
    
    // Set CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    // Handle preflight requests
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    
    if (req.method !== 'POST') {
        return res.status(405).json({ success: false, message: 'Method not allowed' });
    }
    
    try {
        const { apiKey, deviceInfo } = req.body;
        
        if (!apiKey || !deviceInfo) {
            logSecurityEvent('API_VALIDATION_FAILED', 'Missing API key or device info');
            return res.status(400).json({ 
                success: false, 
                message: 'Missing API key or device information' 
            });
        }
        
        // Check if API key exists
        const keyData = apiKeys[apiKey];
        if (!keyData) {
            logSecurityEvent('API_VALIDATION_FAILED', `Invalid key: ${apiKey.substring(0, 10)}...`);
            return res.status(401).json({ 
                success: false, 
                message: 'Invalid API key' 
            });
        }
        
        // Check if API key is expired
        const expiresAt = new Date(keyData.expiresAt);
        if (new Date() > expiresAt) {
            logSecurityEvent('API_VALIDATION_FAILED', `Expired key for: ${keyData.username}`);
            return res.status(401).json({ 
                success: false, 
                message: 'API key expired' 
            });
        }
        
        // Update last used timestamp
        keyData.lastUsed = new Date().toISOString();
        
        logSecurityEvent('API_VALIDATION_SUCCESS', `Username: ${keyData.username}, Access: ${keyData.accessType}`);
        
        return res.status(200).json({
            success: true,
            message: 'API key validation successful',
            username: keyData.username,
            accessType: keyData.accessType,
            keyInfo: {
                createdAt: keyData.createdAt,
                expiresAt: keyData.expiresAt,
                lastUsed: keyData.lastUsed
            },
            deviceId: deviceInfo.fingerprint?.substring(0, 16) + '...'
        });
        
    } catch (error) {
        console.error('API key validation error:', error);
        logSecurityEvent('API_VALIDATION_ERROR', error.message);
        
        return res.status(500).json({
            success: false,
            message: 'Internal server error'
        });
    }
}
